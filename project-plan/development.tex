\chapter{Development}
The development of hardware and software will be done in parallel throughout the project execution.
The purpose of this methodology is to avoid leaving software development until the last stage of project execution, a common issue with hardware projects. 
To achieve this goal, rapid prototyping will be used for hardware development and \gls{xp} techniques will be used for software development. 
These two methodologies compliment each other well, producing deliverables on a regular basis that can be evaluated by the Systems Engineer, who will give feedback to improve the next iteration. 
The rapid hardware prototyping is essential, as some software components rely on the hardware existing before any work can be done.
\section{Hardware}
\section{Software}
\gls{xp} techniques will be used for software development to allow greater flexibility in the system and allow more rapid feature implementation.
Software development will not be an afterthought in this project; the software components will be fully integrated with the hardware components to ensure an optimal product. 
The goal of the software development is to create reliable programs that can be understood and maintained over the course of the Capstone Design Sequence and beyond.
Undocumented and difficult-to-understand code will take more time for modifications and consume more resources for debugging issues, so writing the software with \gls{xp} techniques will save time in the long run.
The most notable improvements over traditional software development techniques that \gls{xp} offers are unit testing, pair programming, and stand-up meetings.

Automated unit testing ensures that code is written modularly, provides verification throughout development, and checks that new changes do not break existing features of the code.
Pair programming spreads knowledge of the software throughout the team and ensures that small programming errors are corrected before they become more difficult to find.
Stand-up meetings provide a brief way to keep all team members up-to-date on the current project status, allowing individuals to help alleviate roadblocks before they delay the entire project. 
\paragraph{Unit Testing}
Programming through unit testing simply means that code for runtime is never written until a failing test proves that it is needed.
This process ensures that all code is written for a reason, and that it does not give unexpected results for any valid set of inputs.
Invalid inputs can also be provided to code and enforce that the program handle the situation gracefully. 
As an added benefit, unit testing enforces that the inputs and outputs of a method be documented, proving examples of how the target function was intended to be used. 

Verification of software is difficult to perform with the end product; some errors may only occur in extreme cases that are unlikely to occur in system testing, allowing the possibility of bugs to pass acceptance testing. 
Unit testing proves that all use cases are covered, and greatly decreases the number of bugs in code.
Tests give the developer a tool for verifying that each piece of code performs exactly what it is required to do throughout development, instead of waiting to test thousands of lines of code at once in acceptance testing.

Throughout development, changes will be made to existing code for refactoring or adding functionality, but unit tests ensure that these changes will not break the code in any way. 
Software often has bugs that only reveal themselves after implementing a seemingly minor change to a program.
Automated unit tests, which can be easily run at any time, verify that any changes being implemented do not cause unexpected issues in other portions of the code.
Whenever a test fails after making a change, the developer can analyze the test to understand how their change caused the test to fail, ultimately correcting the problem before it is fully implemented in the system. 
\paragraph{Pair Programming}
Commonly, one person on a small project team takes over almost all development, creating "knowledge silos" where only one person understands the software.
This habit can be disastrous if that member leaves the team or can no longer participate in the project for any reason.
Additionally, understanding of the project's software is critical when making design choices in other areas, including hardware design, as software limitations may restrict other design choices.
More spread-out knowledge of the project's software benefits all team members, and will ultimately affect the quality of the final product.

Though seemingly a minor outcome, pair programming prevents small bugs from being introduced into the code, which can save much time throughout software development.
Studies have shown that software bugs are most easily found and corrected shortly after being written.
The longer a bug stays in the code, the less familiar the engineers become with that code, resulting in the bug taking longer to correct once it reveals itself later in the project.
The additional pair of eyes in pair programming prevent many small errors that may be glazed over if one person is writing code by themselves.
\paragraph{Stand-up Meetings}
The most important implication of stand-up meetings is the ability to keep software development on time, a task that is easier said than done.
The meeting is performed while standing, to ensure brevity and allow all parties to get back to work as soon as possible.
Despite not taking long, simply discussing the current stage in the development process allows individuals to express any potential roadblocks that may exist and discuss issues they are having.
Often times, another individual on the team may have useful input and may be able to help avoid roadblocks and solve errors, ultimately keeping development on schedule. 